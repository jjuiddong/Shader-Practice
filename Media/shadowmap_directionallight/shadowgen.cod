//
// FX Version: fx_5_0
//
// 8 local buffer(s)
//
cbuffer $Globals
{
    float4  g_outlineColor = { 0.800000012, 0, 0, 1 };// Offset:    0, size:   16
}

cbuffer cbPerFrame : register(b0)
{
    float4x4 gWorld;                    // Offset:    0, size:   64
    float4x4 gView;                     // Offset:   64, size:   64
    float4x4 gProjection;               // Offset:  128, size:   64
    float4x4 gLightView[3];             // Offset:  192, size:  192
    float4x4 gLightProj[3];             // Offset:  384, size:  192
    float4x4 gLightTT;                  // Offset:  576, size:   64
    float3  gEyePosW;                   // Offset:  640, size:   12
}

cbuffer cbLight : register(b1)
{
    float4  gLight_Ambient;             // Offset:    0, size:   16
    float4  gLight_Diffuse;             // Offset:   16, size:   16
    float4  gLight_Specular;            // Offset:   32, size:   16
    float3  gLight_Direction;           // Offset:   48, size:   12
    float3  gLight_PosW;                // Offset:   64, size:   12
    float3  gLight_SpecIntensity;       // Offset:   80, size:   12
}

cbuffer cbMaetrial : register(b2)
{
    float4  gMtrl_Ambient;              // Offset:    0, size:   16
    float4  gMtrl_Diffuse;              // Offset:   16, size:   16
    float4  gMtrl_Specular;             // Offset:   32, size:   16
    float4  gMtrl_Emissive;             // Offset:   48, size:   16
    float   gMtrl_Pow;                  // Offset:   64, size:    4
}

cbuffer cbPerFrameInstancing : register(b3)
{
    float4x4 gWorldInst[256];           // Offset:    0, size: 16384
}

cbuffer cbClipPlane : register(b4)
{
    float4  gClipPlane;                 // Offset:    0, size:   16
}

cbuffer cbSkinning : register(b5)
{
    float4x4 gPalette[64];              // Offset:    0, size: 4096
}

cbuffer cbuffercbShadowMapGS : register(b6)
{
    float4x4 ShadowViewProj[3];         // Offset:    0, size:  192
}

//
// 16 local object(s)
//
Texture2D txDiffuse;
Texture2D txBump;
Texture2D txSpecular;
Texture2D txEmissive;
Texture2D txShadow0;
Texture2D txShadow1;
Texture2D txShadow2;
Texture2D txDepth;
SamplerState samLinear
{
    Filter   = uint(MIN_MAG_MIP_LINEAR /* 21 */);
    AddressU = uint(CLAMP /* 3 */);
    AddressV = uint(CLAMP /* 3 */);
    BorderColor = float4(1, 1, 1, 1);
};
SamplerComparisonState samShadow
{
    Filter   = uint(COMPARISON_MIN_MAG_LINEAR_MIP_POINT /* 148 */);
    AddressU = uint(BORDER /* 4 */);
    AddressV = uint(BORDER /* 4 */);
    AddressW = uint(BORDER /* 4 */);
    BorderColor = float4(1, 1, 1, 1);
};
SamplerComparisonState samDepth
{
    Filter   = uint(COMPARISON_MIN_MAG_LINEAR_MIP_POINT /* 148 */);
    AddressU = uint(BORDER /* 4 */);
    AddressV = uint(BORDER /* 4 */);
    AddressW = uint(BORDER /* 4 */);
    BorderColor = float4(0, 0, 0, 0);
    ComparisonFunc = uint(LESS_EQUAL /* 4 */);
};
SamplerState samAnis
{
    Filter   = uint(ANISOTROPIC /* 85 */);
    AddressU = uint(WRAP /* 1 */);
    AddressV = uint(WRAP /* 1 */);
};
RasterizerState Depth
{
    DepthBias = uint(10000);
    DepthBiasClamp = float(0);
    SlopeScaledDepthBias = float(1);
};
RasterizerState NoCull
{
    CullMode = uint(NONE /* 1 */);
};
DepthStencilState DepthNormal
{
    DepthFunc = uint(LESS_EQUAL /* 4 */);
    DepthEnable = bool(TRUE /* 1 */);
};
DepthStencilState NoDepthStencil
{
    DepthEnable = bool(FALSE /* 0 */);
};

//
// 1 groups(s)
//
fxgroup
{
    //
    // 1 technique(s)
    //
    technique11 Unlit
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 10.1
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerFrame
                // {
                //
                //   float4x4 gWorld;                   // Offset:    0 Size:    64
                //   float4x4 gView;                    // Offset:   64 Size:    64 [unused]
                //   float4x4 gProjection;              // Offset:  128 Size:    64 [unused]
                //   float4x4 gLightView[3];            // Offset:  192 Size:   192 [unused]
                //   float4x4 gLightProj[3];            // Offset:  384 Size:   192 [unused]
                //   float4x4 gLightTT;                 // Offset:  576 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:  640 Size:    12 [unused]
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim      HLSL Bind  Count
                // ------------------------------ ---------- ------- ----------- -------------- ------
                // cbPerFrame                        cbuffer      NA          NA            cb0      1 
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue  Format   Used
                // -------------------- ----- ------ -------- -------- ------- ------
                // POSITION                 0   xyzw        0     NONE   float   xyzw
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue  Format   Used
                // -------------------- ----- ------ -------- -------- ------- ------
                // SV_Position              0   xyzw        0      POS   float   xyzw
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed | skipOptimization
                dcl_constantbuffer CB0[4], immediateIndexed
                dcl_input v0.xyzw
                dcl_output_siv o0.xyzw, position
                dcl_temps 1
                //
                // Initial variable locations:
                //   v0.x <- Pos.x; v0.y <- Pos.y; v0.z <- Pos.z; v0.w <- Pos.w; 
                //   o0.x <- <VS return value>.x; o0.y <- <VS return value>.y; o0.z <- <VS return value>.z; o0.w <- <VS return value>.w
                //
                #line 21 "C:\Work\Project\Shader-Practice\Media\shadowmap_directionallight\shadowgen.fx"
                dp4 r0.x, v0.xyzw, cb0[0].xyzw  // r0.x <- PosW.x
                dp4 r0.y, v0.xyzw, cb0[1].xyzw  // r0.y <- PosW.y
                dp4 r0.z, v0.xyzw, cb0[2].xyzw  // r0.z <- PosW.z
                dp4 r0.w, v0.xyzw, cb0[3].xyzw  // r0.w <- PosW.w
                
                #line 22
                mov o0.xyzw, r0.xyzw
                ret 
                // Approximately 6 instruction slots used
                            
            };
            GeometryShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 10.1
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbuffercbShadowMapGS
                // {
                //
                //   float4x4 ShadowViewProj[3];        // Offset:    0 Size:   192
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim      HLSL Bind  Count
                // ------------------------------ ---------- ------- ----------- -------------- ------
                // cbuffercbShadowMapGS              cbuffer      NA          NA            cb6      1 
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue  Format   Used
                // -------------------- ----- ------ -------- -------- ------- ------
                // SV_Position              0   xyzw        0      POS   float   xyzw
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue  Format   Used
                // -------------------- ----- ------ -------- -------- ------- ------
                // SV_POSITION              0   xyzw        0      POS   float   xyzw
                // SV_RenderTargetArrayIndex     0   x           1  RTINDEX    uint   x   
                //
                gs_5_0
                dcl_globalFlags refactoringAllowed | skipOptimization
                dcl_constantbuffer CB6[12], dynamicIndexed
                dcl_input_siv v[3][0].xyzw, position
                dcl_temps 3
                dcl_inputprimitive triangle 
                dcl_stream m0
                dcl_outputtopology trianglestrip 
                dcl_output_siv o0.xyzw, position
                dcl_output_siv o1.x, rendertarget_array_index
                dcl_maxout 9
                //
                // Initial variable locations:
                //   m0 <- OutStream; 
                //   v[0][0].x <- InPos[0].x; v[0][0].y <- InPos[0].y; v[0][0].z <- InPos[0].z; v[0][0].w <- InPos[0].w; 
                //   v[1][0].x <- InPos[1].x; v[1][0].y <- InPos[1].y; v[1][0].z <- InPos[1].z; v[1][0].w <- InPos[1].w; 
                //   v[2][0].x <- InPos[2].x; v[2][0].y <- InPos[2].y; v[2][0].z <- InPos[2].z; v[2][0].w <- InPos[2].w
                //
                #line 30 "C:\Work\Project\Shader-Practice\Media\shadowmap_directionallight\shadowgen.fx"
                mov r0.x, l(0)  // r0.x <- iFace
                mov r0.y, r0.x  // r0.y <- iFace
                loop 
                  ilt r0.z, r0.y, l(3)
                  breakc_z r0.z
                
                #line 34
                  mov r0.y, r0.y  // r0.y <- output.RTIndex
                
                #line 36
                  mov r0.z, l(0)  // r0.z <- v
                  mov r0.w, r0.z  // r0.w <- v
                  loop 
                    ilt r1.x, r0.w, l(3)
                    breakc_z r1.x
                
                #line 38
                    imul null, r1.x, r0.y, l(4)
                    dp4 r2.x, v[r0.w + 0][0].xyzw, cb6[r1.x + 0].xyzw  // r2.x <- output.Pos.x
                    dp4 r2.y, v[r0.w + 0][0].xyzw, cb6[r1.x + 1].xyzw  // r2.y <- output.Pos.y
                    dp4 r2.z, v[r0.w + 0][0].xyzw, cb6[r1.x + 2].xyzw  // r2.z <- output.Pos.z
                    dp4 r2.w, v[r0.w + 0][0].xyzw, cb6[r1.x + 3].xyzw  // r2.w <- output.Pos.w
                
                #line 39
                    mov o0.xyzw, r2.xyzw
                    mov o1.x, r0.y
                    emit_stream m0
                
                #line 40
                    iadd r0.w, r0.w, l(1)
                  endloop 
                
                #line 41
                  cut_stream m0
                
                #line 42
                  iadd r0.y, r0.y, l(1)
                endloop 
                
                #line 43
                ret 
                // Approximately 25 instruction slots used
                            
            };
            HullShader = NULL;
            DomainShader = NULL;
            PixelShader = NULL;
        }

    }

}

